(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[288],{

/***/ "../EVA Design System/node_modules/brace/mode/coffee.js":
/***/ (function(module, exports) {

eval("ace.define(\"ace/mode/coffee_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(acequire, exports, module) {\n\"use strict\";\n\n    var oop = acequire(\"../lib/oop\");\n    var TextHighlightRules = acequire(\"./text_highlight_rules\").TextHighlightRules;\n\n    oop.inherits(CoffeeHighlightRules, TextHighlightRules);\n\n    function CoffeeHighlightRules() {\n        var identifier = \"[$A-Za-z_\\\\x7f-\\\\uffff][$\\\\w\\\\x7f-\\\\uffff]*\";\n\n        var keywords = (\n            \"this|throw|then|try|typeof|super|switch|return|break|by|continue|\" +\n            \"catch|class|in|instanceof|is|isnt|if|else|extends|for|own|\" +\n            \"finally|function|while|when|new|no|not|delete|debugger|do|loop|of|off|\" +\n            \"or|on|unless|until|and|yes\"\n        );\n\n        var langConstant = (\n            \"true|false|null|undefined|NaN|Infinity\"\n        );\n\n        var illegal = (\n            \"case|const|default|function|var|void|with|enum|export|implements|\" +\n            \"interface|let|package|private|protected|public|static|yield\"\n        );\n\n        var supportClass = (\n            \"Array|Boolean|Date|Function|Number|Object|RegExp|ReferenceError|String|\" +\n            \"Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|\" +\n            \"SyntaxError|TypeError|URIError|\"  +\n            \"ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|\" +\n            \"Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray\"\n        );\n\n        var supportFunction = (\n            \"Math|JSON|isNaN|isFinite|parseInt|parseFloat|encodeURI|\" +\n            \"encodeURIComponent|decodeURI|decodeURIComponent|String|\"\n        );\n\n        var variableLanguage = (\n            \"window|arguments|prototype|document\"\n        );\n\n        var keywordMapper = this.createKeywordMapper({\n            \"keyword\": keywords,\n            \"constant.language\": langConstant,\n            \"invalid.illegal\": illegal,\n            \"language.support.class\": supportClass,\n            \"language.support.function\": supportFunction,\n            \"variable.language\": variableLanguage\n        }, \"identifier\");\n\n        var functionRule = {\n            token: [\"paren.lparen\", \"variable.parameter\", \"paren.rparen\", \"text\", \"storage.type\"],\n            regex: /(?:(\\()((?:\"[^\")]*?\"|'[^')]*?'|\\/[^\\/)]*?\\/|[^()\"'\\/])*?)(\\))(\\s*))?([\\-=]>)/.source\n        };\n\n        var stringEscape = /\\\\(?:x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|[0-2][0-7]{0,2}|3[0-6][0-7]?|37[0-7]?|[4-7][0-7]?|.)/;\n\n        this.$rules = {\n            start : [\n                {\n                    token : \"constant.numeric\",\n                    regex : \"(?:0x[\\\\da-fA-F]+|(?:\\\\d+(?:\\\\.\\\\d+)?|\\\\.\\\\d+)(?:[eE][+-]?\\\\d+)?)\"\n                }, {\n                    stateName: \"qdoc\",\n                    token : \"string\", regex : \"'''\", next : [\n                        {token : \"string\", regex : \"'''\", next : \"start\"},\n                        {token : \"constant.language.escape\", regex : stringEscape},\n                        {defaultToken: \"string\"}\n                    ]\n                }, {\n                    stateName: \"qqdoc\",\n                    token : \"string\",\n                    regex : '\"\"\"',\n                    next : [\n                        {token : \"string\", regex : '\"\"\"', next : \"start\"},\n                        {token : \"paren.string\", regex : '#{', push : \"start\"},\n                        {token : \"constant.language.escape\", regex : stringEscape},\n                        {defaultToken: \"string\"}\n                    ]\n                }, {\n                    stateName: \"qstring\",\n                    token : \"string\", regex : \"'\", next : [\n                        {token : \"string\", regex : \"'\", next : \"start\"},\n                        {token : \"constant.language.escape\", regex : stringEscape},\n                        {defaultToken: \"string\"}\n                    ]\n                }, {\n                    stateName: \"qqstring\",\n                    token : \"string.start\", regex : '\"', next : [\n                        {token : \"string.end\", regex : '\"', next : \"start\"},\n                        {token : \"paren.string\", regex : '#{', push : \"start\"},\n                        {token : \"constant.language.escape\", regex : stringEscape},\n                        {defaultToken: \"string\"}\n                    ]\n                }, {\n                    stateName: \"js\",\n                    token : \"string\", regex : \"`\", next : [\n                        {token : \"string\", regex : \"`\", next : \"start\"},\n                        {token : \"constant.language.escape\", regex : stringEscape},\n                        {defaultToken: \"string\"}\n                    ]\n                }, {\n                    regex: \"[{}]\", onMatch: function(val, state, stack) {\n                        this.next = \"\";\n                        if (val == \"{\" && stack.length) {\n                            stack.unshift(\"start\", state);\n                            return \"paren\";\n                        }\n                        if (val == \"}\" && stack.length) {\n                            stack.shift();\n                            this.next = stack.shift() || \"\";\n                            if (this.next.indexOf(\"string\") != -1)\n                                return \"paren.string\";\n                        }\n                        return \"paren\";\n                    }\n                }, {\n                    token : \"string.regex\",\n                    regex : \"///\",\n                    next : \"heregex\"\n                }, {\n                    token : \"string.regex\",\n                    regex : /(?:\\/(?![\\s=])[^[\\/\\n\\\\]*(?:(?:\\\\[\\s\\S]|\\[[^\\]\\n\\\\]*(?:\\\\[\\s\\S][^\\]\\n\\\\]*)*])[^[\\/\\n\\\\]*)*\\/)(?:[imgy]{0,4})(?!\\w)/\n                }, {\n                    token : \"comment\",\n                    regex : \"###(?!#)\",\n                    next : \"comment\"\n                }, {\n                    token : \"comment\",\n                    regex : \"#.*\"\n                }, {\n                    token : [\"punctuation.operator\", \"text\", \"identifier\"],\n                    regex : \"(\\\\.)(\\\\s*)(\" + illegal + \")\"\n                }, {\n                    token : \"punctuation.operator\",\n                    regex : \"\\\\.{1,3}\"\n                }, {\n                    token : [\"keyword\", \"text\", \"language.support.class\",\n                     \"text\", \"keyword\", \"text\", \"language.support.class\"],\n                    regex : \"(class)(\\\\s+)(\" + identifier + \")(?:(\\\\s+)(extends)(\\\\s+)(\" + identifier + \"))?\"\n                }, {\n                    token : [\"entity.name.function\", \"text\", \"keyword.operator\", \"text\"].concat(functionRule.token),\n                    regex : \"(\" + identifier + \")(\\\\s*)([=:])(\\\\s*)\" + functionRule.regex\n                }, \n                functionRule, \n                {\n                    token : \"variable\",\n                    regex : \"@(?:\" + identifier + \")?\"\n                }, {\n                    token: keywordMapper,\n                    regex : identifier\n                }, {\n                    token : \"punctuation.operator\",\n                    regex : \"\\\\,|\\\\.\"\n                }, {\n                    token : \"storage.type\",\n                    regex : \"[\\\\-=]>\"\n                }, {\n                    token : \"keyword.operator\",\n                    regex : \"(?:[-+*/%<>&|^!?=]=|>>>=?|\\\\-\\\\-|\\\\+\\\\+|::|&&=|\\\\|\\\\|=|<<=|>>=|\\\\?\\\\.|\\\\.{2,3}|[!*+-=><])\"\n                }, {\n                    token : \"paren.lparen\",\n                    regex : \"[({[]\"\n                }, {\n                    token : \"paren.rparen\",\n                    regex : \"[\\\\]})]\"\n                }, {\n                    token : \"text\",\n                    regex : \"\\\\s+\"\n                }],\n\n\n            heregex : [{\n                token : \"string.regex\",\n                regex : '.*?///[imgy]{0,4}',\n                next : \"start\"\n            }, {\n                token : \"comment.regex\",\n                regex : \"\\\\s+(?:#.*)?\"\n            }, {\n                token : \"string.regex\",\n                regex : \"\\\\S+\"\n            }],\n\n            comment : [{\n                token : \"comment\",\n                regex : '###',\n                next : \"start\"\n            }, {\n                defaultToken : \"comment\"\n            }]\n        };\n        this.normalizeRules();\n    }\n\n    exports.CoffeeHighlightRules = CoffeeHighlightRules;\n});\n\nace.define(\"ace/mode/matching_brace_outdent\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar Range = acequire(\"../range\").Range;\n\nvar MatchingBraceOutdent = function() {};\n\n(function() {\n\n    this.checkOutdent = function(line, input) {\n        if (! /^\\s+$/.test(line))\n            return false;\n\n        return /^\\s*\\}/.test(input);\n    };\n\n    this.autoOutdent = function(doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\})/);\n\n        if (!match) return 0;\n\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({row: row, column: column});\n\n        if (!openBracePos || openBracePos.row == row) return 0;\n\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column-1), indent);\n    };\n\n    this.$getIndent = function(line) {\n        return line.match(/^\\s*/)[0];\n    };\n\n}).call(MatchingBraceOutdent.prototype);\n\nexports.MatchingBraceOutdent = MatchingBraceOutdent;\n});\n\nace.define(\"ace/mode/folding/coffee\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../../lib/oop\");\nvar BaseFoldMode = acequire(\"./fold_mode\").FoldMode;\nvar Range = acequire(\"../../range\").Range;\n\nvar FoldMode = exports.FoldMode = function() {};\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        var range = this.indentationBlock(session, row);\n        if (range)\n            return range;\n\n        var re = /\\S/;\n        var line = session.getLine(row);\n        var startLevel = line.search(re);\n        if (startLevel == -1 || line[startLevel] != \"#\")\n            return;\n\n        var startColumn = line.length;\n        var maxRow = session.getLength();\n        var startRow = row;\n        var endRow = row;\n\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var level = line.search(re);\n\n            if (level == -1)\n                continue;\n\n            if (line[level] != \"#\")\n                break;\n\n            endRow = row;\n        }\n\n        if (endRow > startRow) {\n            var endColumn = session.getLine(endRow).length;\n            return new Range(startRow, startColumn, endRow, endColumn);\n        }\n    };\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n        var indent = line.search(/\\S/);\n        var next = session.getLine(row + 1);\n        var prev = session.getLine(row - 1);\n        var prevIndent = prev.search(/\\S/);\n        var nextIndent = next.search(/\\S/);\n\n        if (indent == -1) {\n            session.foldWidgets[row - 1] = prevIndent!= -1 && prevIndent < nextIndent ? \"start\" : \"\";\n            return \"\";\n        }\n        if (prevIndent == -1) {\n            if (indent == nextIndent && line[indent] == \"#\" && next[indent] == \"#\") {\n                session.foldWidgets[row - 1] = \"\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"start\";\n            }\n        } else if (prevIndent == indent && line[indent] == \"#\" && prev[indent] == \"#\") {\n            if (session.getLine(row - 2).search(/\\S/) == -1) {\n                session.foldWidgets[row - 1] = \"start\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"\";\n            }\n        }\n\n        if (prevIndent!= -1 && prevIndent < indent)\n            session.foldWidgets[row - 1] = \"start\";\n        else\n            session.foldWidgets[row - 1] = \"\";\n\n        if (indent < nextIndent)\n            return \"start\";\n        else\n            return \"\";\n    };\n\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/coffee\",[\"require\",\"exports\",\"module\",\"ace/mode/coffee_highlight_rules\",\"ace/mode/matching_brace_outdent\",\"ace/mode/folding/coffee\",\"ace/range\",\"ace/mode/text\",\"ace/worker/worker_client\",\"ace/lib/oop\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar Rules = acequire(\"./coffee_highlight_rules\").CoffeeHighlightRules;\nvar Outdent = acequire(\"./matching_brace_outdent\").MatchingBraceOutdent;\nvar FoldMode = acequire(\"./folding/coffee\").FoldMode;\nvar Range = acequire(\"../range\").Range;\nvar TextMode = acequire(\"./text\").Mode;\nvar WorkerClient = acequire(\"../worker/worker_client\").WorkerClient;\nvar oop = acequire(\"../lib/oop\");\n\nfunction Mode() {\n    this.HighlightRules = Rules;\n    this.$outdent = new Outdent();\n    this.foldingRules = new FoldMode();\n}\n\noop.inherits(Mode, TextMode);\n\n(function() {\n    var indenter = /(?:[({[=:]|[-=]>|\\b(?:else|try|(?:swi|ca)tch(?:\\s+[$A-Za-z_\\x7f-\\uffff][$\\w\\x7f-\\uffff]*)?|finally))\\s*$|^\\s*(else\\b\\s*)?(?:if|for|while|loop)\\b(?!.*\\bthen\\b)/;\n    \n    this.lineCommentStart = \"#\";\n    this.blockComment = {start: \"###\", end: \"###\"};\n    \n    this.getNextLineIndent = function(state, line, tab) {\n        var indent = this.$getIndent(line);\n        var tokens = this.getTokenizer().getLineTokens(line, state).tokens;\n    \n        if (!(tokens.length && tokens[tokens.length - 1].type === 'comment') &&\n            state === 'start' && indenter.test(line))\n            indent += tab;\n        return indent;\n    };\n    \n    this.checkOutdent = function(state, line, input) {\n        return this.$outdent.checkOutdent(line, input);\n    };\n    \n    this.autoOutdent = function(state, doc, row) {\n        this.$outdent.autoOutdent(doc, row);\n    };\n    \n    this.createWorker = function(session) {\n        var worker = new WorkerClient([\"ace\"], require(\"../worker/coffee\"), \"Worker\");\n        worker.attachToDocument(session.getDocument());\n        \n        worker.on(\"annotate\", function(e) {\n            session.setAnnotations(e.data);\n        });\n        \n        worker.on(\"terminate\", function() {\n            session.clearAnnotations();\n        });\n        \n        return worker;\n    };\n\n    this.$id = \"ace/mode/coffee\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n\n});\n\n\n//# sourceURL=webpack:///../EVA_Design_System/node_modules/brace/mode/coffee.js?");

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiIyODguNTI1MGE1YjE5MGE3YmY1Y2EyZDguY2h1bmsuanMiLCJzb3VyY2VSb290IjoiIn0=